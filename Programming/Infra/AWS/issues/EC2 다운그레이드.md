## 서론

수익이 없는 사이드 프로젝트이기 때문에 AWS 비용이 너무 부담스러웠다. (월 50000원 이상 과금)
현재 사용하고 있는 인스턴스는 t3.medium이다.
- 개발 환경으로서는 불편함이 전혀 없었다. 서버의 메모리 또한 4GB로 너무나도 넉넉했다. 그 점에서 **오버스펙이 아닐까?** 하는 의문이 들었다.

이에 EC2 인스턴스 다운그레이드를 고민하게 되었다.


## 다운그레이드

우선 한 단계 아래인인 t3.small 인스턴스로 다운그레이드를 진행했다.
비교적 무거운 작업인 자동배포 파이프라인을 실행함으로써 적합한 인스턴스인지 검증해보겠다.


## Jenkins가 멈췄다...

![[Pasted image 20240308200455.png]]

2분 26초 대에서 더 이상 진행되지 않는다.
SSH로 접속한 서버도 거의 사용할 수 없을 정도로 느렸다.

느려터진 서버 콘솔로 Jenkins 컨테이너를 재시작해서야 이 녀석을 멈출 수 있었다.

뭐가 문제였을까?

### CPU 사용률

![[Pasted image 20240308213905.png|400]]

Jenkins 빌드를 실행하고 종료할 때까지의 CPU 사용량이다.
peek 지점이 55%인 것을 미루어 보아, CPU 사용률이 이 현상의 문제라고 할 수는 없을 것 같다.

CPU가 문제가 없으니, **메모리 부족으로 인한 hang 현상이 의심되었다.**

### 메모리 사용량

![[Pasted image 20240308205650.png]]

**total**: 전체 메모리 크기
**used**: 사용 중인 메모리 크기
**free**: 시스템에서 사용 가능한 잔여 메모리 크기
**buff/cache**: 캐시 영역으로 사용하는 메모리 크기
**available**: swapping 없이 애플리케이션을 실행 가능한 가용 메모리 크기
ref) https://brunch.co.kr/@dreaminz/2

현재 약 40% 정도의 메모리를 사용하고 있다.


**빌드가 멈추는 시점**인 2분쯤 다시 메모리 사용량을 확인해보았다.

![[Pasted image 20240308212713.png]]

약 98%의 메모리를 사용하고 있었다.
아마 계속 진행했다면, 시스템이 엄청나게 느려지는 현상을 다시 경험할 수 있었을 것이다...

이로써 **메모리 부족이 해당 문제의 원인임을 파악**할 수 있었다.


### 스왑메모리 지정을 통한 해결 시도

인스턴스의 메모리 크기는 2GB... 그마저도 Jenkins 컨테이너가 40%를 점유하고 있다.

메모리가 한정적인 경우, **추가적으로 Disk에 Swap 영역을 지정**하여 이를 **가상의 메모리처럼 사용**할 수 있다.
이를 통해 메모리 부족 현상을 해결해보자.

ref1) [RAM 용량에 따른 적정 스왑메모리 용량](https://help.ubuntu.com/community/SwapFaq#How_much_swap_do_I_need.3F)
ref2) [스왑 파일을 사용하여 Amazon EC2 인스턴스에서 스왑 공간으로 사용할 메모리를 할당하는 방법은 무엇입니까?](https://repost.aws/ko/knowledge-center/ec2-memory-swap-file)

위의 레퍼런스를 참고하여 Swap 영역의 크기를 4GB로 잡았다.

### 결과

![[Pasted image 20240309025533.png]]

해냈구나, 젠킨스!
그러나 배포 시간이 약 10% 증가했다. (263s -> 289s)

#### CPU 사용률

![[Pasted image 20240308215927.png|400]]

엄청난 수치다... 왜 이렇게 CPU가 열일했을까?
추측컨데, 사용 가능한 메모리 양이 적기 때문에 Swap-in/out이 빈번하게 일어나지 않았을까?
- **페이지 폴트가 많이 발생 ➡️ Swap-in/out 많이 발생(Disk I/O) ➡️ CPU 사용률 증가**
- 그러나 대부분의 사
그리고 이는 빌드 속도에도 충분히 영향이 있었을 것이다.

#### 메모리 사용량

**빌드 시작 전**
![[Pasted image 20240309030433.png]]

**빌드 시작 2분 경과 후**
![[Pasted image 20240309030459.png]]

**빌드 시작 2분 경화 후 docker stats**
```bash
// Docker 컨테이너 리소스 모니터링
docker stats
```

![[Pasted image 20240309034951.png]]

메모리를 점유하던 Jenkins 컨테이너의 많은 부분이 swap-out 되었음을 알 수 있다.
Swap 영역을 활용하여 부족한 메모리를 잘 보완함으로써 빌드를 무사히 마칠 수 있었다.


## 성과

AWS 이용 요금을 100% 절약할 수 있었다. (34$ ➡️ 17$)

서비스에 맞는 **아키텍처를 먼저 구상해보는 과정**이 있었다면, 여태 지불했던 비용을 아낄 수 있었을텐데...하는 아쉬움이 남았다.

서버 리소스를 **모니터링**하는 경험을 했고, 서버의 가용성을 위해서는 **메모리 관리가 매우 중요함**을 깨달았다.


## 다음 이야기

### Jenkins 만을 위한 인스턴스?

현재 인스턴스 선택의 기준은 Jenkins가 돌아갈 수 있는지?이다.
많은 CICD 도구들 중 Jenkins를 선택한 이유는 단순히 이를 학습하기 위해서였는데, 관련된 지식을 어느정도 쌓았고, 혼자서 파이프라인 구축이 가능할 정도인 지금은 더 이상 Jenkins를 고집할 이유가 없어졌다.

즉, 우리가 t3.small을 쓰는 이유가 Jenkins가 되어서는 안된다는 것이다.

그래서 인스턴스 선택의 기준을 **비용**으로 변경하고자 한다. (물론 API 요청을 처리할 수 있는 최소한의 성능도!)
- 현재 개발단계이고, 전혀 수익을 내지 않고 있기 때문에, 지출을 최대한 줄이고 싶은 마음이 크다...

다음 과제로는 지금까지 사용했던 Jenkins를 Github Action으로 이전해보고, 인스턴스 유형을 재조정해 볼 예정이다..!

[[Jenkins ➡️ Github Actions]]


