## 동시성 문제란?

Spring은 스레드풀 기반의 다중스레드로 동작한다.
그렇기 때문에 스레드풀에 할당된 스레드의 개수만큼 동시에 요청을 받을 수 있다.

동시에 요청을 받을 수 있다는 것은 자원에 대한 경쟁상태가 발생할 수 있다는 뜻이기도 하다.

예시로 스트리머에게 1000원을 동시에 10번 후원했다고 하자.
우리는 스트리머의 수익 10000원이 되기를 기대할 것이다.

그러나 여러 번 테스트를 진행해본다면 10000원 이하의 금액이 수익으로 들어오는 케이스들을 확인할 수 있을 것이다.
**스트리머가 온전히 받아야 할 수익 중 일부가 누락된 것이다.** 
(금전적인 부분이 얽혀 있으므로 아주 심각한 문제라고 할 수 있다)

왜 이렇게 되는지 예시와 함께 살펴보자.

![[Pasted image 20240302190609.png]]

스트리머에게 후원을 하는 프로세스는 다음과 같다.
1. 스트리머의 현재 총 수익을 조회한다.
2. 스트리머에게 후원 금액을 후원한다.
이러한 DB의 상태를 변경하는 최소한의 프로세스를 **트랜잭션**이라고 부른다.

스트리머의 **총 수익**은 서비스 전체에서 공유되는 **공유자원**이다.
TX1이 commit되기 전에 TX2에서 스트리머의 총 수익을 조회한 결과는 1000원이다.
그렇기 때문에 TX1와 TX2의 수행 결과, 스트리머의 총 수익은 2000원이 된다.
1000원이 누락된 상태가 된다.


## 트랜잭션 격리 수준 조정을 통한 해결?

**JPA에서는 트랜잭션 격리 수준을 상향한다고 위의 문제를 해결할 수 없다.**
그 이유는 격리를 위해 공유락을 사용하기 때문이다.
**공유락의 경우에는 쓰기 연산 만을 제한**하기에 트랜잭션의 초반에 스트리머의 총 수익을 읽는 연산을 제한할 수 없다. ([이를 두 번의 갱신 분실 문제라고 한다](https://velog.io/@on5949/JPA-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EB%9D%BD-3.-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD%EA%B3%BC-%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD))
#### 격리 수준
- 해당 트랜잭션이 다른 트랜잭션에서 **변경한 데이터를 볼 수 있는 기준**
#### Lock
- 다른 트랜잭션에서 해당 데이터에 접근하는 것을 막는 기능

### 두 번의 갱신 분실 문제 해결(?) 방법

#### 마지막 커밋만 인정하기
- 먼저 수정한 내용은 덮어씌워진다.
#### 최초 커밋만 인정하기
- 두 번째 사람이 수정을 시도할 때 오류가 발생한다.
#### 충돌하는 갱신 내용 병합
- 두 사람의 수정사항을 병합한다.

기본적으로는 먼저 수정한 내용이 덮어 씌워지게 된다.
그러나 위 사례처럼 어느 하나라도 수정사항이 덮어씌워져선 안될 경우에는 어떻게 해야 할까?


## 어떻게 해결해야 하지?

### 낙관적 락과 비관적 락

[[낙관적 락]]

[[비관적 락]]


## Ref

[JPA - 비관적 락, 낙관적 락 (+ 트랜잭션 격리 수준) 정리!](https://jaehoney.tistory.com/159)
[트랜잭션과 락 - 3. 낙관적 락과 비관적 락](https://velog.io/@on5949/JPA-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EB%9D%BD-3.-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD%EA%B3%BC-%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD)