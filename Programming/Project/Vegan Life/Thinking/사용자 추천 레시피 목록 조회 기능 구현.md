## 요구사항

1. 사용자 추천 레시피 목록은 `VegetarianType`을 기준으로 **랜덤으로 4개를 선정**한다.
2. **매일 자정** 사용자 추천 레시피 목록을 새로고침한다.

## 구현

### Batch와 Cache를 사용할까?

Batch를 이용해 자정에 사용자 별로 추천 레시피 목록을 조회하고 이를 Cache 메모리에 저장한다.
- 조회 시 Cache 메모리 만을 조회하면 된다. (조회 성능 개선)

그러나 만약 Cache 메모리의 내용이 예상치 못하게 휘발된다면 자정이 아닌 시간대에 다시 Batch를 수행해야 한다.
- 사용자가 몰려있는 시간대라면 처리에 지연이 있을 것이고, 사용성 측면에서 불편함을 줄 것이다.

물론 Redis의 snapshot과 같은 기능을 사용해 복구할 수도 있다.
- 그러나 트레이드 오프가 존재한다. 
- [Redis 백업](https://gencomi.tistory.com/entry/Redis-%EB%B0%B1%EC%97%85)

가장 중요한 문제가 있다!!!
만약 레시피가 수정되었다면 이를 하나하나 업데이트 해주어야 한다.
- 레시피는 수정될 일이 많은 테이블인가?

### Cache를 사용할 필요가 있을까?

하루 동안은 거의 동일한 내용을 조회할 것이기 때문에 Cache를 사용하려고 했다.
그러나 조회 성능 개선을 위해 Cache를 사용하는 것이 의미가 없을 수도 있다는 생각을 했다.
- [조회 기능을 RDB 대신 Redis Cache로 대체하는 것은 효율적일가?](https://80000coding.oopy.io/7ebc2496-b0cb-4011-98bf-6d56373bc059)

1. 조회 성능이 개선될 것이라는 보장도 없을 뿐더러
2. 만약 레시피 테이블 수정이 생각보다 많이 이루어진다면 오히려 이를 대조하고 업데이트하는 과정의 오버헤드가 더 클 것이고
3. 안 그래도 적은 메모리 용량을 낭비하는 것이라고 생각해 현재로서는 Cache를 사용할 필요성을 느끼지 못했다.


## 두 가지의 구현 방법

### Random을 사용할까?

그렇다면 어떻게 사용자 별로 하루동안 항상 같은 추천 레시피 목록을 보여줄 수 있을까?

이를 위해 난수를 사용하기로 했다.
1. seed 값은 그 날의 날짜와 사용자 ID를 조합해서 사용한다. (`LocalDate.now().toEpochDay()`)
2. seed 값을 이용해 page 번호를 랜덤으로 선택한다. (page size는 20으로 한다)
3. seed 값을 이용해 page 내에서 랜덤으로 4개의 레시피를 선택한다.

단, 한국 시간대를 기준으로 하기 때문에 해외에서는 자정에 추천 레시피가 변경되지 않을 수도 있다.
+) 먼저 count query를 날려서 총 몇 개의 레코드가 있는지 확인이 필요하다. (쿼리가 2배!)
+) 애플리케이션 단에서 예외 상황에 대한 로직을 짜주어야 한다. (totalElement가 4 이하라면?, )

### Native Query를 사용할까?

**`order by rand()` 절을 추가해서 랜덤으로 추출할 수 있다!**
- 쿼리 실행 순간에 레코드에 각각 임의의 값을 할당하고, 그 값으로 정렬을 수행한다.
- 그러나 이는 인덱스를 활용할 수 없는 조건이기 때문에 비효율적이라고 할 수 있다.

**인덱스를 활용할 수 있도록 튜닝할 수 있다.**
- [SELECT 문으로 데이터 랜덤으로 가져올 경우에 대한 성능 테스트](https://javairus.tistory.com/19)

### `order by rand()`에 시드값이 제대로 적용되지 않는 이슈

시드값에 따라 항상 동일한 랜덤 값을 반환할 수 있도록 `order by rand(seed)` 절을 사용하여 추천 레시피를 조회하는 쿼리를 작성하였다.
그러나 시드값이 동일하면 동일한 레코드를 반환할 것이라고 예상했지만, 조회마다 항상 다른 레코드를 반환했다.

그 이유는 `order by rand()`가 수행되는 방식 때문이다.
현재 엔티티에는 random value에 해당하는 column이 지정되어 있지 않다.
그렇기 때문에 DB는 조회 때마다 임의로 각각의 레코드에 random value를 할당하고 이를 정렬한다.
- `rand(seed)`가 동일한 랜덤 값을 반환하는 것은 맞다, 그러나 이게 조회 때마다 다른 레코드의 컬럼으로 들어가기 때문에 항상 다른 값을 반환했던 것이다.

[ORDER BY rand() 쿼리문 튜닝하기!](https://leezzangmin.tistory.com/28) 
해당 게시글을 참고하여 `randId`라는 컬럼을 추가하고 해당 값을 기준으로 정렬하면 된다.
랜덤으로 값을 추출하기 위해서는 조회할 범위의 시작지점을 랜덤으로 지정하면 된다!

### `randId`는 어떤 방식으로 생성해야 할까?

아래의 게시글을 참고하여 UUID로 랜덤 값을 생성하고자 했다.
[Generating Unique Positive long Using UUID in Java](https://www.baeldung.com/java-uuid-unique-long-generation)

다만 `randId`가 겹치는 상황이 발생할 수도 있다는 단점이 있다.

### 4개의 Page Size로 가져올 경우의 문제점

만약 총 레코드의 개수가 21개라면 **마지막 페이지의 경우에는 하나의 레코드만을 반환**하게 된다.
이는 4개의 추천 레시피를 가져와야 한다는 요구사항을 어기게 되는 것이다.

이런 특수한 상황에서는 부족한 레코드들을 한 번 더 조회해야 한다.
- 단, 이미 조회한 레코드는 조회하지 않는다.

### Page Size를 1로 해서 4번 쿼리 조회 vs 최대한 1번의 쿼리로 조회 성능 차이

반드시 비교해보자!!