
## Java 8 이후의 HashMap 동작과정

Java의 HashMap은 Separate Chaning 방식을 사용한다.
Java 7 이전에는 구현을 위한 자료구조로 링크드 리스트를 사용했다.
Java 8부터는 링크드 리스트를 사용하면서도, **데이터가 많은 경우에는 트리로 전환한다.
- 해시 충돌이 많이 발생하더라도 **트리를 탐색**하기 때문에 링크드 리스트를 사용했을 보다 성능 문제가 많이 완화된다!
- 링크드 리스트: O(n), 트리: O(log(n))

**생일 문제 (birthday problem)**
- 사람이 366(윤년이면 367)명 모여있을 때, 반드시 생일이 같은 쌍이 나오나, 실제로는 그보다 훨씬 적은 수로도 생일이 같은 쌍이 나와 발생하는 문제

**실제 해시 값은 균등분포가 아니다.**
- 해시 버킷 몇 개에 데이터가 집중될 수 있다! (생일 문제)
- 그렇기 때문에 데이터의 개수가 많다면 트리를 사용하는 것이 이득이다.

**데이터가 많은 경우?**
- HashMap에 그 기준이 상수 형태로 정의되어 있다.
- 8개 이상이면 트리로 전환, 다시 6개 이하로 내려가면 링크드 리스트로 전환

**트리로는 Red-Black Tree를 사용한다.**

**해시 버킷을 동적으로 확장한다.**
- 해시 버킷의 개수가 적다면 메모리를 아낄 수 있으나, 해시 충돌이 더욱 빈번하게 발생하여 성능상으로 손실이 발생한다.
- HashMap은 **키-값 쌍 데이터 개수가 일정 이상**이 되면, **해시 버킷의 개수를 두배로 늘린다.**
- 버킷을 확장할 때마다, 모든 키-값 데이터를 읽어 새로운 Separate Chaining을 구성해야 한다.
	- 생성자에 초기 해시 버킷 개수를 미리 정해두어 이러한 오버헤드를 피할 수 있다.


ref) https://d2.naver.com/helloworld/831311


## 32bit vs 64bit JVM에서의 해시충돌 발생률

해시테이블의 크기는 아키텍처와 직접적인 관련이 없다.
- **해시 함수의 구현에 영향을 받는다!**

32bit와 64bit JVM에서 사용하는 해시 함수는 일반적으로 동일하기 때문에, **64bit JVM의 경우 더 넓은 주소 공간을 상대적으로 작은 해시 테이블에 매핑**해야 한다.

그렇기 때문에 32bit JVM보다 64bit JVM의 해시충돌 발생률이 높다.

