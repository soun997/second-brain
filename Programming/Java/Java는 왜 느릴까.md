## 서론

다들 Java는 느린 언어라는 인식이 있다.
도대체 어떤 특성을 가진 언어길래 이렇게 느리게 동작하는 것일까?

먼저 Java 애플리케이션의 실행에 필요한 JVM에 대해서 알아보겠다.

## JVM

JVM은 Java 어플리케이션을 실행하는 가상 머신이다.
- **인터프리터**와 **JIT 컴파일러**를 통해 바이트 코드를 각 운영체제 맞는 기계어로 해석시켜서 실행한다.
	- 여기서 말하는 바이트 코드는 `.class` 파일을 의미한다.
- JVM 명세를 따르기만 한다면, 누구나 JVM을 개발하여 제공할 수 있다.

```
1. **HotSpot JVM**: Oracle에서 개발한 자바 SE 표준 에디션의 기본 JVM입니다. HotSpot은 성능이 우수하고 널리 사용되는 JVM 중 하나입니다.
    
2. **OpenJ9**: IBM에서 개발한 오픈 소스 JVM입니다. OpenJ9은 성능 최적화와 메모리 효율성을 강조하며, 클라우드 및 엔터프라이즈 환경에서 사용됩니다.
    
3. **GraalVM**: Oracle Labs에서 개발한 다목적 가상 머신으로, 자바 외에도 다양한 언어를 지원합니다. GraalVM은 최신 JIT(Just-In-Time) 컴파일러 및 AOT(Ahead-of-Time) 컴파일러를 포함하여 성능과 확장성을 높이는 데 초점을 맞추고 있습니다.
    
4. **Azul Zing**: Azul Systems에서 개발한 JVM으로, 대규모 기업 환경에서의 성능 및 안정성을 강조합니다. Zing은 특히 대용량 트랜잭션 처리 및 실시간 분석과 같은 요구 사항을 가진 애플리케이션에 적합합니다.
```

### Runtime Data Area

![[Pasted image 20240308030141.png]]

JVM은 프로그램을 실행하면서 다양한 런데임 데이터 영역을 사용한다.
- 스레드들이 공유하는 데이터 영역
- 스레드별로 할당되는 데이터 영역

JVM을 구동하면 **Heap** 영역과 **Method** 영역이 생성된다.
- 해당 영역은 모든 스레드들이 공유한다.

스레드가 시작될 때마다, 각 스레드별로 **PC Register**, **Native Method Stack**,**Stack** 영역이 생성된다.
- 스레드가 종료되면 해당 영역은 반환된다.

모든 스레드가 종료되면 JVM이 종료되면서 Heap 영역과 Method 영역도 사라진다.

#### PC Register
- JVM이 현재 실행중인 명령어의 주소를 저장한다.
#### Frame
- 데이터, 반환 값을 저장하는 자료구조이다.
- 함수 호출 시 생성되고, 종료 시 사라진다.
- 동적 할당은 코드 실행 시점에 심볼릭 링크를 해석해 고정된 주소값으로 변환시킨다.
	- **심볼릭 링크를 통한 Late Binding이 바로 객체지향의 핵심이다.**
		- Early Binding: 어떤 타입인지 초기에 알려줌, Runtime 이전에 컴파일러가 메모리 할당
		- **Late Binding**: 어떤 타입인지 나중에 알려줌, 객체의 교체 가능성이 있을 경우 사용
			- 덕분에 다형성을 구현할 수 있구나!
#### Stack
- Frame을 저장한다.
- 지역 변수, 함수의 실행 결과 저장, 함수 호출과 반환을 담당한다.
	- 디버깅 해보면 스택 구조처럼 동작함을 확인할 수 있다.
#### Native Method Stack
- 다른 언어로 작성된 코드를 실행할 때 사용되는 스택이다. (Java 플젝에서 Kotlin을 실행할 수 있는 이)
- 초기에는 Java 언어만을 실행할 수 있었지만, 이후 다른 언어들도 실행할 수 있도록 확장됨
#### Heap
- 클래스의 인스턴스와 배열이 저장되는 공간이다.
- 가비지 컬렉션에 의해 관리된다.
- Heap 구성 방식, 가비지 컬렉션 알고리즘은 JVM을 구현하면서 자유롭게 선택할 수 있다.
- String Constant Pool은 이곳에 존재한다. (GC 대상은 아님)
#### Method
- Runtime Constant Pool, 필드, 함수, 코드 등의 클래스, 인터페이스 구조가 저장되는 공간이다.
#### Runtime Constant Pool
- 런타임 상수 풀은 클래스, 인터페이스마다 존재하며, 클래스 파일의 constant pool 테이블 영역이 저장된다.
- 클래스나 인터페이스의 전역 변수/함수, 인스턴스 변수/함수
	- 전역 변수/함수는 컴파일 시점에 할당되어 고정된 값으로 존재한다.
	- 인스턴스 변수/함수는 심볼릭 링크가 존재한다.
	- 클래스
- 클래스가 생성되어 Heap에 할당될 때 만들어진다.


## JVM의 동작 원리

### STEP1. Java 실행 엔진

JVM마다 다르게 구현될 수 있다.
Oracle의 Hotspot을 기준으로 어떻게 동작하는지 살펴보도록 하겠다.

![[Pasted image 20240308040830.png|500]]

1. Java 코드를 JAVAC 컴파일러를 사용해서 바이트코드로 변환한다.
2. 기본적으로 인터프리터가 라인별로 바이트 코드를 읽어 실행한다. 
3. 자주 등장하는 바이트 코드일 경우, JIT 컴파일러를 사용해 컴파일하여 성능을 최적화시킨다.
	1. 바이트코드 '언어'는 기본적으로 **인터프리터 방식으로 동작**한다.
		1. 실행 중에 코드가 수정되거나 추가되어도 이를 동적으로 실행할 수 있다.
	2. 인터프리터만을 사용할 경우 명령어를 **하나씩 해석하고 실행**하기 때문에, 명령어 하나하나의 해석은 빠르지만, 인터프리팅 결과의 실행은 느리다. (초기 로딩은 빠르지만, 실행 중에 지연이 발생할 수 있다.)
	3. 인터프리터의 단점을 보완하기 위해, JIT 컴파일러를 사용하여 **적절한 시점에 바이트코드 전체를 컴파일**하여 네이티브 코드로 변경한다. 이후에는 해당 부분을 더 이상 인터프리팅하지 않는다.
	4. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 이후로도 빠르게 실행할 수 있다. 

### STEP2. Class Loader

![[Pasted image 20240308175649.png]]

클래스 로더는 `.class` 파일의 바이트코드를 읽어 Runtime Data Area로 가져온다.

1. 위임모델
	1. 자신에게 클래스 로딩 요청이 들어오면 자신의 부모 클래스 로더에게 요청을 보낸다.
	2. 만약 부모 클래스 로더가 클래스를 찾지 못하면, 그 후에 자신이 클래스를 탐색한다.
2. 계층구조
	1. 상위 클래스 로더는 하위 클래스 로더에게 보인다. 그러나 그 반대는 불가능하다.
		1. 상속을 생각하면 된다.
	2. 클래스 로더의 책임을 분리하고, 클래스 로더는 자신이 책임지는 클래스를 로딩할 수 있다.

아래의 클래스 로더는 부모-자식 순으로 기재하였다.
### Bootstrap Class Loader

네이티브 코드로 작성되어 있으며, JVM에 내장되어 있다.
JVM이 시작될 때 실행되며, `java.lang.package`처럼 JVM 실행에 필요한 클래스들을 로딩한다.

### Platform Class Loader

`java.lang.ClassLoader`의 인스턴스로, Java SE platform API 등 Java에서 기본적으로 제공해주는 클래스를 로딩할 때 사용한다.

### System Class Loader

`java.lang.ClassLoader`의 인스턴스로, 유저가 작성한 클래스를 로딩할 때 사용한다.
ClassPath에 명시된 경로를 통해서 클래스를 찾는다. (ex. `src/main/java`)


## 그래서 JVM은...

Java 애플케이션을 실행하는 데에 필수적인 역할을 한다.


## 그래서 왜 Java가 느린데?

공부하면서 깨달은 것이, "Java는 느리다"라는 말은 잘못됐다는 것이다.
"**Java는 처음 실행하는 데에 많은 시간이 소요된다.**"라고 고칠 수 있을 것 같다.

왜 그런 것인지 정리해보자.

### 바이트코드 컴파일 단계 추가

C 애플리케이션의 실행 방식과 비교를 해보겠다.
#### C 애플리케이션을 실행하는 방법 (한 번 비교해 보자)
- **전처리 - 컴파일링 - 어셈블링 - 링킹**
- 전처리: 애플리케이션에 포함된 헤더파일에서 사용하는 것들을 불러온다.
- 컴파일링: C 소스코드를 어셈블리 코드로 변환한다.
- 어셈블링: 어셈블리 코드를 오브젝트 코드(0과 1)로 변경한다.
- 링킹: 프로그램 하나에 여러 개의 오브젝트 파일이 생기게 된다. 이를 하나의 오브젝트 파일로 합친다. 
	➡️ 실행파일
> https://marinadb.tistory.com/3

소스코드 - 어셈블리코드 - 오브젝트코드와 같은 변환 단계를 거치는 것을 확인할 수 있다.

Java는 소스코드 - 바이트코드 - 어셈블리코드 - 오브젝트코드 순으로 변환된다.
즉, **바이트코드로 컴파일하는 과정이 추가**되는 것이다.

### JVM 로드의 필요성

위에서 알아봤듯이, Java 애플리케이션을 실행하려면 반드시 JVM이 로드되어야 한다.
- 그 덕분에 **플랫폼 종속성**이라는 특성을 가지게 되었다.

컴파일 언어들은 컴파일링 과정을 거쳐 운영체제에서 직접 실행되기 때문에 JVM 같은게 필요 없다.
- 플랫폼에 종속적일 수 밖에 없다.
- 예를 들어, Windows와 Ubuntu에서 각각 C 프로그램을 실행하려고 해도, 컴파일러의 종류나 라이브러리 의존성의 차이로 인해 실행을 하지 못할 수 있다.

### JIT 컴파일러

만약 JIT 컴파일러 없이 인터프리터로만 동작했다면, 초기 실행 과정에서 컴파일에 소요되는 시간이 줄어들게 될 것이다..

그러나 문제는 실행 중에 발생한다.
JIT 컴파일러가 있다면, 컴파일 과정을 거쳐 최적화된 코드를 실행하기 때문에 성능, 메모리 측면에서 우수하다.
인터프리터만 있다면, 계속 명령어를 해석하고 실행하기 때문에 실행 중 속도저하가 발생할 수 있으며, 메모리 사용량도 훨씬 늘어날 것이다.
- 그렇기 때문에 **대부분의 JVM은 JIT 컴파일러를 포함**하고 있다.

**초기화 단계에서 최적화를 위한 컴파일링 과정이 추가**될 수 있기 때문에, 결과적으로 소요되는 시간이 늘어난다.




## Ref

https://velog.io/@sgwon1996/JAVA%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC%EC%99%80-JVM-%EA%B5%AC%EC%A1%B0
https://hongsii.github.io/2018/12/20/jvm-memory-structure/