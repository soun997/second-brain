## 서론

조회 성능 최적화를 위해 인덱스를 생성했다.
그러나 인덱스를 생성하기 전과 후의 실행시간 차이가 크지 않았다.

직접 실행계획을 확인하면서 무엇이 문제인지 확인해보고자 한다.

현재 예상 가능한 문제는
1. **인덱스 컬럼을 가공했기 때문에 인덱스 스캔 시작 지점을 찾지 못했다.**
2. 인덱스를 생성하기 위한 컬럼 조합이 잘못되었다.

## SQL 실행계획 분석

### 데이터의 형태

- 2024.01.01일 부터 2024.05.29까지, 150일 동안
- 100명의 사용자는 하루에 3개(아침, 점심, 저녁)의 식단 기록을 작성한다.

### 실행하려고 하는 쿼리

- 사용자 한 명이 연간 섭취한 칼로리를 조회하는 쿼리
- 인덱스 컬럼을 **가공했을 때**의 실행계획 vs 인덱스 컬럼을 **가공하지 않았을 때**의 실행계획 비교

### 추가한 인덱스

- (사용자 ID + 식단기록 일자) 조합의 인덱스를 생성했다.

### 확인하고자 하는 것

- 인덱스 컬럼을 가공했을 경우, 인덱스를 사용하지 않는지 검증


## 컬럼을 가공 했을 때/가공하지 않았을 때 비교

### 인덱스를 타지 않았을 때

```sql
## 인덱스 타지 않음  
explain select ml.meal_type, sum(m.calorie)  
from meal_log ml join meal m on ml.meal_log_id = m.meal_log_id  
and ml.member_id = 50  
and cast(ml.created_at as date) between '2024-01-01' and '2024-12-31'  
group by ml.meal_type;
```

![[Pasted image 20240313182023.png|1000]]
(순서대로 드라이빙 - 드리븐 테이블이다)
#### meal table
1. select_type: 서브쿼리나 UNION을 사용하지 않았기 때문에 SIMPLE
2. type: ALL이기 때문에 Table Full-Scan으로 작동했음을 알 수 있다.
3. key: `null`이기 때문에 인덱스를 사용하지 않았음을 알 수 있다.
4. rows: 총 90000개의 row를 읽었다.
#### meal-log table
1. select_type: 서브쿼리나 UNION을 사용하지 않았기 때문에 SIMPLE
2. type: eq_ref, 조인 조건이 `meal_log_id`이기 때문에, `meal_log` 테이블에서는 단 한 건만 조회하게 된다.
3. key: PK를 인덱스로 사용했다.
4. rows: 총 1개의 row를 읽었다.

인덱스를 사용하지 않았을 경우, **평균적으로 160ms가 소요**되었다.
실행계획을 분석한 결과 바깥 쪽 조인 테이블인 `meal` 테이블의 모든 rows들을 풀스캔하였다. (인덱스를 사용하지 않았다)

#### 의문점 1

왜 레코드 수가 더 적은 `meal_log` 테이블이 드라이빙 테이블이 아닌가?






![[Pasted image 20240316053655.png]]

- **인덱스로 사용하는 컬럼인 `created_at`을 가공**했기 때문에 인덱스 스캔 시작지점을 찾지 못한다.
-  DBMS: 날짜는 알겠는데... 시간 정보는 안 주어졌는걸? 어디서부터 시작해야 하지?

그나마 다행인 건 **Table Full Scan**은 랜덤 액세스 방식이 아니라 **블록 단위로 순차적으로 모두 읽는다**는 것이다.
- 데이터 양이 더 많았다면 더욱 오래걸렸을 것이다!


### 인덱스를 탔을 때

```sql
## 인덱스 탐  
explain select ml.meal_type, sum(m.calorie)  
from meal_log ml join meal m on ml.meal_log_id = m.meal_log_id  
where ml.member_id = 1  
and ml.created_at between "2024-01-01 00:00:00" and "2024-12-31 00:00:00"  
group by ml.meal_type;
```

![[Pasted image 20240313182720.png|1000]]
(순서대로 드라이빙 - 드리븐 테이블이다)
#### meal-log table
1. select_type: 서브쿼리나 UNION을 사용하지 않았기 때문에 SIMPLE
2. type: ref, PK가 아닌 것을 key로 사용하고 있기 때문에
3. key: (member_id + created_at) 인덱스로 사용하고 있다.
4. rows: 총 450개의 row를 읽었다.
#### meal table
1. select_type: 서브쿼리나 UNION을 사용하지 않았기 때문에 SIMPLE
2. type: ref, PK가 아닌 것을 key로 사용하고 있기 때문에
3. key: FK(meal_log_id)를 인덱스로 사용하고 있다.
4. rows: 총 45000개의 row를 읽었다.

인덱스를 사용하지 않았을 경우, **평균적으로 40ms가 소요**되었다.