## 서론

조회 성능 최적화를 위해 인덱스를 생성했다.
그러나 인덱스를 생성하기 전과 후의 실행시간 차이가 크지 않았다. (똑같이 느렸다)
SQL 실행계획을 분석했을 때, 아예 인덱스 테이블을 사용 대상으로도 넣지 않았다.

인덱스 컬럼을 가공한 것도 아니고, `IN`이나 `OR`을 쓰지도 않았는데!!!

도대체 이유가 무엇일까?

## 테스트 데이터

### 데이터의 형태

- 2024.01.01일 부터 2024.05.29까지, 150일 동안
- 100명의 사용자는 하루에 3개(아침, 점심, 저녁)의 식단 기록을 작성한다.

### 실행하려고 하는 쿼리

- 사용자 한 명이 연간 섭취한 칼로리를 조회하는 쿼리

### 추가한 인덱스

- (사용자 ID + 식단기록 일자) 조합의 인덱스를 생성했다.


## 예상대로 동작하지 않는다..?

### JPA로 추가한 인덱스가 적용이 안되는 이슈 및 해결 시도

현재 진행 중인 사이드 프로젝트에서는 JPA 어노테이션을 사용해 DB 테이블에 대한 인덱스를 자동으로 생성한다.
그러나 나중에 실행계획을 확인했을 때, 인덱스가 존재함에도 이를 이용하지 않는 이슈를 발견했다.

![[Pasted image 20240317202822.png]]
![[Pasted image 20240317202849.png]]
(도대체 왜 Table Full Scan을 하는거지!)

자동으로 생성된 인덱스를 지우고 **수동으로 생성**한 다음, 다시 실행계획을 확인했을 때는 인덱스를 제대로 사용하는 것을 확인할 수 있었다.

**예상되는 이유**
1. DataGrip 문제, refresh 해보기 ➡️ 효과 없음
2. DataGrip 문제, 재실행 해보기 ➡️ 효과 없음
3. DataGrip 문제, MySQL로 실행계획 확인 ➡️ 효과 없음
4. FK 문제, 테이블에 FK 인덱스가 빠져있는데, 그 탓인가? ➡️ 아님
5. JPA 문제, 자동으로 생성된 인덱스는 적용되지 않는다? ➡️ 이건가..?

### 개발자 포럼에 질문

개발자 포럼에 질문을 해보았다.
https://okky.kr/questions/1492819

기존의 인덱스를 지우고 수동으로 새로 만들어 주면, **DBMS 통계 정보도 같이 업데이트** 되기 때문에 Optimizer에 영향을 준 것이라는 내용이었다!

내가 이해한 바는 다음과 같다.
1. 애플리케이션을 시작하면서 DB 스키마 생성 (내가 만든 인덱스도)
2. 테스트 데이터 삽입
3. 아직 기존의 통계 정보를 기반으로 하기 때문에 인덱스를 타지 않음
4. 기존의 인덱스를 지우고, 수동으로 다시 만들어주면 DBMS의 통계 정보 업데이트
5. 업데이트된 통계 정보에 따라 새로운 실행계획 작성

그렇다면 인덱스를 지웠다가 다시 만들 필요 없이, **통계 정보만 업데이트**하면 제대로 동작한다는 것일까?

## 테이블 통계 정보 업데이트 해주기

### 어떤 통계 정보들이 있을까?

일단 현재 어떤 통계 정보들이 있는지 확인해보겠다.

```sql
use mysql;
show tables like '%_stats';
```

![[Pasted image 20240316192617.png]]

이중에서 `innodb_index_stats` 테이블과 `innodb_table_stats`를 들여다 봐보자.

### `innodb_index_stats`

![[Pasted image 20240316194941.png|1000]]

내가 생성한 인덱스들이 잘 있었다.

### `innodb_table_stats`

![[Pasted image 20240316195103.png|1000]]

뭔가 이상하다.
현재 `meal_log`, `meal` 테이블에는 수많은 테스트 데이터가 들어있는 상태이다.
그런데 `n_rows`의 값이 0이라고?
`member` 테이블의 `n_rows` 또한 현재 데이터와 맞지 않았다.

**즉, 통계 정보가 현재 테이블들의 상태를 반영하지 못하고 있었다.**

### 통계 정보

일단 각 테이블에 대한 통계 정보를 업데이트 한 뒤 다시 시도해보겠다.

```sql
analyze table meal_log, meal, member;
```

![[Pasted image 20240317203006.png]]

삽입한 테스트 데이터들 또한 통계 정보에 잘 포함되어 있는 것을 확인할 수 있었다.

이제 다시 기존의 쿼리를 날려보겠다.

```sql
explain select ml.meal_type, sum(m.calorie)  
from meal_log ml join meal m on ml.meal_log_id = m.meal_log_id  
where ml.member_id = 1  
and ml.created_at between "2024-01-01 00:00:00" and "2024-12-31 00:00:00"  
group by ml.meal_type;
```

![[Pasted image 20240317203031.png]]
![[Pasted image 20240317203045.png]]

원하는 대로 인덱스를 잘 사용하고 있는 것을 확인할 수 있었다!!


## Batch 연산 이후로 쿼리가 느려지는 현상

https://dataonair.or.kr/?kboard_content_redirect=62485
Batch 연산 이후로 **통계정보를 갱신해주지 않으면** 옵티마이저의 실행계획 선택에 있어 비효율을 초래할 수 있다고 한다.

즉, 다량의 테스트 데이터를 넣은 이후(Batch 연산 이후) 바로 쿼리를 실행했기 때문에 예상과 다른 실행계획을 선택한 것이다!

통계정보를 주기적으로 갱신할 필요가 있음을 깨닫게 되었다.


## 결론

DBMS가 인덱스를 활용하지 못했던 이유는 Batch 연산 이후 **업데이트되지 않은 통계정보를 사용**했기 때문이었다.
- 적절한 실행계획을 선택하지 못했다.

이에 **`analyze` 키워드를 사용하여 직접 업데이트** 해줌으로써 이 문제를 해결할 수 있었다.

옵티마이저는 굉장히 편리하긴 하지만, 다양한 변수를 기반으로 실행계획을 지정하기 때문에 이를 염두에 두고 사용해야 한다.
가끔 왜 이런 식으로 실행계획을 짜나 싶을 때가 있었는데... 이런 이유였군!


## Ref

[실행 계획 통계 정보와 실행 계획을 확인하는 방법](https://jjingho.tistory.com/175)
[analyze 명령 과 DBMS stats 패키지](https://blog.naver.com/mided/60186695680)