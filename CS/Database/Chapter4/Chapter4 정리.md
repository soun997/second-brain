## 4.1 [[NL 조인]]

### 4.1.1 기본 메커니즘

NL 조인은 [[인덱스]]를 이용한 조인이다.

```java
for (int i = 0; i < 100; i++) {    -- outer loop
	for (int j = 0; j < 100; j++) {    -- inner loop
		...
	}
}
```

NL(Nested Loop) 조인은 위의 중첩 루프문과 같은 수행 구조를 가진다.

### 4.1.2 NL 조인 실행계획 제어

`use_nl` 힌트를 사용하여 NL 방식으로 조인하라고 지시할 수 있다.
`ordered`, `leading`과 같은 힌트를 사용하여 조인 순서를 제어할 수 있다.
- 순서에 관한 힌트를 기술하지 않으면 옵티마이저가 스스로 정한다.

### 4.1.3 NL 조인 수행 과정 분석

수행의 각 단계를 모두 완료하고 넘어가는 것이 아니라 한 레코드 씩 순차적으로 진행함을 확인할 수 있다.
- 정말 for-loop의 동작 방식과 유사하다!

### 4.1.4 NL 조인 튜닝 포인트

Outer 테이블과 Inner 테이블의 인덱스를 튜닝함으로써 비효율을 개선할 수 있다.
- Outer 테이블 -> 전체 결과 레코드 개수, 테이블 랜덤 액세스 횟수를 최적화 
- Inner 테이블 ->  조인 액세스 횟수, 테이블 랜덤 액세스 횟수를 최적화
- [[인덱스 튜닝 기법]]

### 4.1.5 NL 조인 특징 요약

1. 랜덤 액세스 위주의 조인 방식이다.
	1. 인덱스 구성이 아무리 완벽해도 대량 데이터 조인에 불리하다.
2. 한 레코드씩 순차적으로 진행한다.
	1. 부분범위 처리를 활용하면 대량의 데이터라도 매우 빠른 응답속도를 낼 수 있다.
	2. 먼저 액세스되는 테이블의 처리 범위에 의해 전체 일량이 결정된다.
3. 인덱스 구성 전략이 특히 중요하다.

결론적으로 소량의 데이터를 주로 처리하거나, 부분범위 처리가 가능한 OLTP 시스템에 적합한 조인 방식이다.

### 4.1.6 NL 조인 튜닝 실습


### 4.1.7 NL 조인 확장 메커니즘

#### 테이블 Prefetch

인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 [[버퍼캐시]]에 적재한다.

`nlj_prefetch`, `no_nlj_prefetch` 힌트를 이용해 실행계획을 설정할 수 있다.

#### 배치 I/O

디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리한다.
- 읽는 블록마다 건건이 I/O Call을 발생시킬 필요가 없다.

`nlj_batching`, `no_nlj_batching` 힌트를 이용해 실행계획을 설정할 수 있다.

Inner 테이블 블록을 모두 버퍼캐시에서 읽는다면 성능에 큰 차이는 없다.
그러나, 일부를 디스크에서 읽게 되면 성능 차이가 날 수 있다.
- 왜지?

또한 결과집합의 정렬 순서가 달라질 수도 있기 때문에 주의가 필요하다.
- `no_nlj_bathcing` 힌트를 추가하거나 ORDER BY 절을 명시해주어야 한다.


## 4.2 [[소트 머지 조인]]

조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인이여서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택한다.


### 4.2.1 SGA vs. PGA

#### SGA

공유 메모리 영역인 ==SGA==에 캐시된 데이터는 여러 프로세스가 공유할 수 있다.
- 그러나 동시에 액세스할 수는 없다.
- 프로세스 간 액세스 직렬화를 위한 Lock 매커니즘으로 [[래치]](Latch)가 존재한다.

DB [[버퍼캐시]]는 SGA의 가장 핵심적인 구성요소로, 여기서 블록을 읽기 위해 버퍼 Lock을 얻어야 한다.

#### PGA

오라클 서버 프로세스에 할당된 메모리 영역은 ==PGA==라고 부르며, 프로세스에 종속적인 고유 데이터를 저장한다.

독립된 메모리 공간이므로 래치 매커니즘이 불필요하여 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠르다.

### 4.2.2 기본 매커니즘

#### 소트 단계

양쪽 집합을 조인 컬럼 기준으로 정렬한다.

#### 머지 단계

정렬한 양쪽 집합을 서로 머지한다.

#### SQL 수행 과정

소트 머지 조인은 `use_merge` 힌트로 유도할 수 있다.

1. 양쪽 테이블을 조인 컬럼을 기준으로 정렬한다.
	1. 정렬한 결과 집합은 PGA 영역에 할당된 Sort Area에 저장한다.
	2. Temp -> Disk I/O
2. Outer 테이블의 레코드를 스캔하면서 Inner 테이블의 레코드와 조인한다.
	1. 머지 단계는 NL 조인과 다르지 않다.

Sort Area에 저장한 데이터 자체가 인덱스 역할을 하므로 조인 컬럼에 인덱스가 없어도 사용할 수 있다.

### 4.2.3 소트 머지 조인이 빠른 이유

NL 조인은 인덱스를 이용한 조인 방식으로, 조인 과정에서 액세스 하는 모든 블록을 랜덤 액세스 방식으로 읽는다.
- 버퍼캐시(SGA)에서 데이터를 읽기 떄문에 래치 획득 과정이 필요하다.
- 건건이 버퍼캐시를 공유해야 한다.

소트 머지 조인은 조인 대상 집합을 일괄적으로 읽어 PGA에 저장한 후 조인한다.
- PGA에서 데이터를 읽기 때문에 래치 획득 과정이 필요없다.
- 양쪽 집합에 대한 소트 연산을 추가로 하기 때문에 느리지 않을까?
	- 그렇기 때문에 대량 데이터 조인 시 유리하다.

그러나 소트 머지 조인도 ==양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유==한다.
- 이때 인덱스를 이용하기도 하기 때문에 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 피할 수 없다.

### 4.2.4 소트 머지 조인의 주용도

해시 조인의 등장으로 조금 뒷전으로 밀려났다.
그래도 소트 머지 조인을 사용할 수 있는 상황이 있다.

1. 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
	1. 해시 조인은 조인 조건식이 등치(=)일 때만 사용할 수 있다.
2. 조인 조건식이 아예 없는 조인 (카테시안 곱)

### 4.2.5 소트 머지 조인 제어하기

 NL 조인과 마찬가지로 `ordered`, `leading` 힌트로 순서를 제어할 수 있다.

### 4.2.6 소트 머지 조인 특징 요약

1. 소트 머지 조인은 PGA 영역에 저장한 데이터를 사용하기 떄문에 빠르다.
	1. 소트 부하만 감수한다면, NL 조인보다 빠르다.
2. 소트 머지 조인은 조인 컬럼에 대한 인덱스의 유무에 크게 영향을 받지 않는다.
3. 스캔 위주의 액세스 방식을 사용한다.
	1. 양쪽 테이블로부터 조인 대상 레코드를 찾을 때에는 인덱스를 이용할 수도 있다.


## 4.3 해시 조인

소트 머지 조인은 항상 양쪽 테이블을 정렬하는 부담이 있지만 해시 조인은 그런 부담도 없다.
그러나 모든 조인을 해시 조인으로 처리할 수는 없기 때문에 각 조인 방식의 특성을 이해하고 상황에 맞게 선택하는 것이 좋다.

### 4.3.1 기본 매커니즘

#### Build 단계

작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성한다.

#### Probe 단계

큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인한다.

#### SQL 수행 과정

`use_hash` 힌트를 사용해 해시 조인을 유도할 수 있다.

1. 조건을 만족하는 **작은 쪽 테이블의 레코드를 읽어 해시 테이블을 생성**한다.
	1. 조인 컬럼을 해시 함수에 입력해 반환된 값으로 해시 체인을 찾고, 그 해시 체인에 데이터를 연결한다.
		1. 해시 테이블에는 SQL에 사용한 컬럼을 모두 저장한다!
	2. 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장한다.
2. 조건을 만족하는 **큰 쪽 테이블을 테이블의 레코드를 하나씩 읽어 해시 테이블을 탐색**한다.
	1. 조인 컬럼을 해시 함수에 입력해 반환된 값으로 해시 체인을 찾는다.
	2. 해시 체인을 스캔해서 조인 컬럼과 같은 값이 있는지 탐색한다.

### 4.3.2 해시 조인이 빠른 이유

소트 머지 조인과 비슷하게, **해시 테이블을 PGA 영역에 할당**하기 때문이다.
- 버퍼캐시 래치 획득 과정이 필요없다.

그러나 해시 조인도 Build Input과 Probe Input 테이블을 읽을 때는 버퍼캐시를 경유한다.
- 이때 인덱스를 이용하기도 하기 때문에 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 피할 수 없다.

PGA의 데이터를 이용한다는 점은 소트 머지 조인과 비슷하지만 무슨 차이가 있을까?

해시 조인의 사전 준비 작업은 양쪽 집합 중 작은 집합을 Build Input으로 선택하기 때문에 **Hash Area를 벗어난 Temp(Disk)에 쓰는 작업은 거의 일어나지 않는다**.

### 4.3.3 대용량 Build Input 처리

두 테이블 모두 대용량일 경우 인메모리 해시 조인은 불가능할 것이다.
이 때 DBMS는 어떤 방식으로 해시 조인을 처리할까?
- 분할&정복 방식을 사용한다.

#### 파티션 단계

조인하는 양쪽 집합 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 **파티셔닝**한다.
- 독립적으로 처리할 수 있는 작은 서브 집합으로 분할함으로써 파티션 짝을 생성한다.
- 양쪽 집합을 읽어 디스크 Temp 공간에 저장해야 하므로 인메모리 해시 조인보다는 성능이 떨어진다.

#### 조인 단계

각 파티션 짝에 대해 하나씩 조인을 수행한다.
- 이 때, 각각에 대한 Build Input과 Probe Input은 독립적으로 결정된다.
- 파티션 짝 별로 작은 쪽을 Build Input으로 선택한다.

### 4.3.4 해시 조인 실행계획 제어

Build Input을 사용자가 직접 선택하고 싶다면, `ordered`나 `leading` 힌트를 사용한다.

#### 세 개 이상 테이블 해시 조인

`leading` 힌트를 지정해주면 된다.
- Build Input을 지정해주고 싶다면 `swap_join_inputs` 힌트를 사용한다.
- Probe Input을 지정해주고 싶다면 `no_swap_join_inputs` 힌트를 사용한다.

### 4.3.5 조인 메서드 선택 기준

![[Pasted image 20231228213427.png|500]]

#### 소량 데이터, 대량 데이터의 기준?

NL 조인 기준으로 '최적화를 했는데도' 랜덤 액세스가 너무 많아 만족할만한 성능을 낼 수 없을 때를 의미한다.

#### 수행 빈도가 매우 높은 쿼리

![[Pasted image 20231228213622.png|400]]

**인덱스**는 Drop하지 않는 한, 영구적으로 유지하면서 다양한 쿼리를 위해 **공유 및 재사용**하는 구조이다.
이에 비해 **해시 테이블**은 **단 하나의 쿼리를 위해 생성하고, 조인이 끝나면 바로 소멸**하는 자료구조이다.
- 같은 쿼리를 100개 수행하면 해시 테이블도 100개가 만들어진다.

즉, 해시 조인은 **배치 프로그램**, **OLAP 쿼리**일 경우에 사용하는 것이 좋다.


## 4.4 서브쿼리 조인

실무에서는 복잡한 서브쿼리와 조인하는 형태를 흔히 보게 된다.
그렇기 때문에 옵티마이저가 서브 쿼리 조인을 어떻게 처리하는지 이해하고, 원하는 방식으로 실행계획을 제어할 수 있어야 한다.

### 4.4.1 서브쿼리 변환이 필요한 이유

옵티마이저는 사용자로부터 전달받은 SQL을 최적화에 유리한 형태로 변환하는 ==쿼리 변환==을 진행한다.
- 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성한다.

#### 서브 쿼리

하나의 SQL문 안에 괄호로 묶은 별도의 쿼리 블록을 말한다.

##### 인라인 뷰
- FROM 절에 사용한 서브 쿼리
##### 중첩된 서브쿼리
- WHERE 절에 사용한 서브 쿼리
##### 스칼라 서브쿼리
- 주로 SELECT-LIST에서 사용하는 서브 쿼리 (정확히 하나의 값 반환)
- 컬럼이 올 수 있는 대부분 위치에서 사용 가능

서브쿼리를 포함하는 메인 쿼리 또한 하나의 쿼리 블록이며, ==옵티마이저는 쿼리 블록 단위로 최적화==한다.
- **서브쿼리 별로 최적화한 쿼리가 전체적으로도 최적화 되었다고는 할 수 없다!**

### 4.4.2 서브쿼리와 조인

서브쿼리는 메인쿼리에 종속되므로 단독으로 실행할 수 없다.
- 메인쿼리 건수만큼 값을 받아 반복적으로 필터링하는 방식으로 실행해야 한다.
- 즉, **실제 추출된 건수 만큼 서브쿼리가 반복적으로 실행된다**는 의미이다.
	- **서브쿼리가 반복적으로 실행되므로 성능이 나쁠까?**
		- 메인쿼리에서 추출되는 건수가 적다면, filter로도 충분히 좋은 성능을 낼 수 있다.
		- 메인쿼리에서 추출되는 건수가 많아도 값의 종류가 적다면 그만큼 서브쿼리를 수행하는 횟수가 줄어들기 때문에 성능이 크게 나쁘지는 않다. (캐싱 덕분?)

#### 필터 오퍼레이션

서브쿼리를 필터 방식으로 처리할 때의 실행계획이다.
- `no_unnest` - 서브쿼리를 풀어내지 말고 그대로 수행하라는 의미의 힌트
- 기본적으로 NL 조인과 처리 루틴이 같다.

##### NL 조인과의 차이
- 필터는 **메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간** 진행을 멈추고, 메인쿼리의 다음 로우를 처리한다.
	- 중복을 막기 위함이다.
- 서브쿼리 **입력 값에 따른 반환 값을 캐싱하는 기능**을 가진다.
	- 서브쿼리를 수행하기 전에 항상 캐시부터 확인한다.
	- 쿼리 단위로 PGA 영역에 캐싱이 이루진다.
- 조인 순서가 고정된다. (메인쿼리가 드라이빙 집합)

#### 서브쿼리 Unnesting

서브쿼리를 그대로 두면 보통 필터 방식을 사용하게 되지만, Unnesting하고 나면 조인처럼 다양한 최적화 기법을 사용할 수 있다.

##### NL 세미조인
- 기본적으로는 NL 조인과 같은 프로세스
- 조인에 성공하는 순간 진행을 멈추고 다음 로우를 처리한다.
- 사실상 필터 오퍼레이션과 큰 차이가 없다.
- EXISTS, NOT EXISTS 연산을 사용할 때 세미조인을 사용할 수 있음 (조건 만족하면 끝!)

##### Unnesting, 왜하는건데...

NL 세미조인이 필터오퍼레이션과 큰 차이가 없다면, 왜 Unnesting하는 것일까?
1. **조인 순서를 유연하게 가져갈 수 있다.** (서브쿼리가 드라이빙 집합이 될 수 있음)
	1. 그러나 메인쿼리의 결과집합이 서브쿼리 집합 수준으로 확장될 수 있기 때문에, 서브쿼리 집합에 대한 중복을 제거하는 연산을 해주어야 한다. (성능이 오히려 떨어지지 않을까?)
2. **조인 메서드를 선택할 수 있다.**
	1. NL 세미조인, Hash 세미조인 등등...

옵티마이저는 많은 조인 테크닉을 가지고 있기 때문에
필터 오퍼레이션보다 **조인 형태로 변환했을 때 더 좋은 실행경로를 찾을 가능성이 크다.**

##### ROWNUM 조심해서 사용하기

조건절을 만족하는 레코드를 지정한 개수만큼 찾고 나면 **필터링을 더 진행하지 않고 멈추게 하고 싶을 때** `rownum`을 사용한다.
- `rownum`을 잘 사용하면 쿼리 성능을 높이는 데 아주 효과적이다.

그러나 `rownum`을 서브쿼리에 사용하는 것은 Unnesting을 막기 때문에 **옵티마이징 기능을 사용하지 못하게 된다.**
- **서브쿼리에 적용된 힌트가 전혀 동작하지 않게 된다.**

#### 서브쿼리 Pushing

Unnesting 되지 않은 **서브쿼리는 항상 필터 방식**으로 처리되며, 대개 실행계획 상에서 맨 마지막 단계에 처리된다.
- 대부분의 I/O는 조인 과정에서 발생하기 때문에, **서브쿼리 필터링을 먼저 처리함으로써 조인 단계로 넘어가는 로우 수를 크게 줄일 수 있다면** 성능은 그만큼 향상된다.

##### Pushing 기능 사용 전

![[Pasted image 20240117203433.png|700]]

##### Pushing 기능 사용 후

![[Pasted image 20240117203505.png|700]]

Pushing 서브쿼리는 서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능이다.
- `push_subq`, `no_push_subq` 힌트로 제어한다.
- 단, Unnesting 되지 않은 서브쿼리에만 작동한다. (위의 힌트는 무조건 `no_unnest` 힌트와 같이 사용!)

### 4.4.3 뷰(View)와 조인

최적화의 단위가 쿼리 블록이기 때문에, 옵티마이저가 View 쿼리를 변환하지 않으면 해당 쿼리를 독립적으로 최적화한다.
- 만약 **필터링 조건이 뷰 바깥에 있다면**, **인라인 뷰 안에서는 필터링되지 않은 조건으로 쿼리를 실행**하게 되어 매우 큰 비효율을 초래할 수 있다.

#### 뷰를 메인쿼리와 Merging하기

`merge` 힌트를 사용해 메인쿼리와 뷰를 머징할 수 있다.

아래는 전월 이후 가입한 고객들의 당월에 발생한 거래에 대한 집계 쿼리이다.
##### View Merging 전

![[Pasted image 20240117204249.png|700]]
##### View Merging 후

![[Pasted image 20240117204315.png]]

위 쿼리의 단점은 조인에 성공한 전체 집합을 `group by` 하고서야 데이터를 출력할 수 있다는 점이다.
- 즉, **부분범위 처리가 불가능**하다는 것이다.
	- [전체범위처리 vs. 부분범위처리 : SQL 작성 전 알아두면 1%라도 도움되는 개념](https://infocean.co.kr/%EC%A0%84%EC%B2%B4%EB%B2%94%EC%9C%84%EC%B2%98%EB%A6%AC-vs-%EB%B6%80%EB%B6%84%EB%B2%94%EC%9C%84%EC%B2%98%EB%A6%AC-sql-%EC%9E%91%EC%84%B1-%EC%A0%84-%EC%95%8C%EC%95%84%EB%91%90%EB%A9%B4-1%EB%9D%BC/)
	- 이럴 때에는 NL 조인보다는 해시 조인을 사용하는 것이 좋다.
- 전월 이후 가입한 고객이 매우 많고, 당월 거래도 매우 많다면 어떨까?

#### 조인 조건 Push down

메인쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어넣는 기능이다. (11g 이후 제공)

![[Pasted image 20240117205546.png|500]]

위의 쿼리를 아래와 같이 최적화했다고 생각하면 된다.
- 인라인 뷰 안에서 메인쿼리 테이블 컬럼을 참조했기 때문에, 문법적으로는 올바르지 않은 쿼리이긴 하다.

![[Pasted image 20240117205553.png|500]]

이렇게 최적화한 쿼리는 (1)전월 이후 가입한 고객을 대상으로 (2)'건건이' 당월 거래 데이터만 읽어서 조인하고 `group by`를 수행 한다.
- 중간에 멈출 수 있다, 즉, 부분범위 처리가 가능하다.

`push_pred` 힌트를 사용해 제어할 수 있지만, 옵티마이저가 뷰를 머징하면 작동하지 않기 때문에 `no_merge`힌트를 함계 사용해야 한다.

### 4.4.4 스칼라 서브쿼리 조인

#### 스칼라 서브 쿼리의 특징

스칼라 서브쿼리는 **컨텍스트 스위칭 없이 메인쿼리와 서브쿼리를 한 몸체처럼 실행**한다.

스칼라 서브쿼리를 조인과 유사하다고 생각할 수도 있다.
그러나 차이가 있다면, 스칼라 서브쿼리는 처리 과정에서 **캐싱 작용**이 일어난다.

#### 스칼라 서브쿼리 캐싱 효과

스칼라 서브쿼리로 조인할 때, 조인 횟수를 최소화하기 위해 입력 값과 출력 값을 내부 캐시에 저장해둔다.
- 조인할 때마다 캐시에서 입력 값을 찾고, 찾았다면 저장된 출력 값을 반환한다.
- 캐시에서 찾지 못했을 때만 조인을 수행한다.

스칼라 서브쿼리의 입력 값은, 그 안에서 참조하는 메인쿼리의 컬럼 값이다.

![[Pasted image 20240117211733.png|500]]

##### 캐싱 효과를 이용한 튜닝 기법

SELECT-LIST에 사용한 함수는 메인쿼리의 결과 건수만큼 반복 수행된다.
이 때, 함수에 **스칼라 서브쿼리를 덧씌우면** 캐싱 효과 덕분에 호출 횟수를 최소화할 수 있다.
- 사용자 정의 함수는 매우 무겁기 때문에 튜닝이 필요하다!

#### 스칼라 서브쿼리 캐싱 부작용

캐시 공간은 늘 부족하다.

스칼라 서브쿼리 캐싱 효과는 **입력 값의 종류가 소수**여서 **해시 충돌 가능성이 작을 때** 효과가 있다.
- 반대의 경우에는 캐시를 매번 확인하는 비용 때문에 오히려 성능이 나빠지고, CPU 사용률만 높아지며, 메모리도 더 사용한다.

##### 입력 값의 종류가 너무 많은 경우

단 20개의 값만이 존재하는 거래구분코드

![[Pasted image 20240117212330.png|500]]

100만개의 값이 존재하는 고객번호

![[Pasted image 20240117212337.png|500]]

일단 캐시에 도저히 담을 수 없을 만큼의 고객 번호가 존재하고, 대부분은 캐시에서 찾지 못하고 조인해야 한다.

##### 메인쿼리의 집합이 너무 작은 경우

스칼라 서브쿼리 캐싱은 쿼리 단위로 이루어지기 때문에 **메인쿼리 집합이 클 수록 재사용성이 높아진다.**

메인쿼리의 집합이 너무 작은 경우에는, 얼마 쓰지도 않을 캐시를 할당해서 값을 채웠다가 바로 버리게 된다.
- 전체적으로 이런 패턴을 불필요하게 많이 사용했을 때, 시스템에 미치는 영향을 생각하자.

#### 두 개 이상의 값 반환

스칼라 서브쿼리에는 치명적인 제약이 하나 있다.
바로 두 개 이상의 값을 반환할 수 없다는 것이다.

##### 불가한 쿼리

![[Pasted image 20240117213147.png|500]]

##### 대안?

![[Pasted image 20240117213220.png|500]]

그러나 거래 테이블에서 같은 데이터를 반복해서 읽는 비효율이 발생한다.

##### 전통적인 방식

![[Pasted image 20240117213513.png]]

구하는 값들을 문자열로 모두 결합하고, 바깥쪽 액세스 쿼리에서 `substr()`로 분리하는 방식이다.

##### 인라인 뷰 사용하기

사실 이런저런 고민 없이 인라인 뷰를 사용하는 것이 편하긴 하다.

그러나 뷰를 사용하면 생각해야 할 내용들이 많다.
1. 뷰가 머징되지 않았을 때의 비효율
2. 뷰가 머징되었을 때의 `group by` 부분범위 처리 문제

그러나 오라클 11g 이후로는 **조인 조건 Pushdown** 기능이 추가되어서 인라인 뷰를 편하게 사용할 수 있게 되었다.

#### 스칼라 서브쿼리 Unnesting

스칼라 서브쿼리도 NL 방식으로 조인하기 때문에, 캐싱 효과가 크지 않으면 랜덤 I/O에 대한 부담이 있다.
- 특히, 병렬 쿼리에서는 될 수 있으면 사용하지 않는 것이 좋다.

그렇기 때문에, 스칼라 서브쿼리를 일반 조인문으로 변환하고 싶을 때가 있다.
- 사용자가 이를 직접 변환한다고 생각하면 한숨부터 나온다.

오라클 12c부터는 스칼라 서브쿼리도 Unnesting이 가능해졌다.
그러나 하위 버전을 쓰다가 업그레이드 하는 경우에는 문제가 많나보다...
