# 3.1 테이블 액세스 최소화

## 3.1.1 테이블 랜덤 액세스

[[인덱스]] 튜닝을 공부하면서 두 번 놀란다.
1. 데이터가 많아도 인덱스를 사용하니까 데이터가 금방 조회되네!
2. 데이터가 많아서 인덱스를 사용했는데 Table Full Scan보다 느리네!

인덱스로 검색하는데, 왜 Table Full Scan보다 느린 상황이 발생할까?
=> 이를 알게 되면 SQL 튜닝의 핵심을 더 정확히 이해할 수 있다.

#### [[인덱스 ROWID]]는 물리적 주소? 논리적 주소?

테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문에 **논리적 주소라고 할 수 있다.**

#### [[메인 메모리 DB]]와의 비교

ROWID는 포인터로 구현할 수 없다.

테이블 블록은 버퍼캐시에 적재되고 삭제되기를 반복하며 그때마다 항상 다른 공간에 캐싱되기 때문에, 
인덱스에서 포인터로 직접 연결할 수 없다.

그렇기 때때문에 디스크 DB는 메모리 DB의 성능을 따라갈 수 없다.

#### [[Disk IO 매커니즘]]

Disk IO의 성능을 높이기 이해 [[버퍼캐시]]를 활용한다.
그러나 버퍼캐시 또한 동시성 제어를 필요로 하기 때문에, 동시 액세스가 심할 경우 많은 비용이 든다.

이처럼 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다.

#### 인덱스 ROWID는 우편주소

디스크 DB의 ROWID는 우편주소, 메모리 DB의 포인터는 전화번호에 비유할 수 있다.
- **이런 비유를 통해 인덱스 ROWID를 통한 테이블 액세스가 얼마나 고비용의 연산인 지 알 수 있다.**


## 3.1.2 인덱스 클러스터링 팩터

클러스터링 팩터가 좋을 수록 [[인덱스 검색 효율]]이 좋다.

왜냐하면 [[버퍼 Pinning]]을 사용하여 실제 블록 I/O가 발생하는 횟수를 줄일 수 있기 때문이다.

클러스터링 팩터가 좋지 않을 경우 인덱스를 사용하면
테이블을 액세스하는 횟수만큼 블록 I/O가 발생하게 된다.


## 3.1.3 [[인덱스 손익분기점]]

인덱스 스캔이 항상 좋은 것은 아니며, Table Full Scan이 항상 나쁜 것은 아니다.

#### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

- [ ] 본서 완독 후 다시 이 부분 읽어보기

온라인 프로그램 튜닝은 보통 소량의 데이터를 읽고 갱신한다.
- [[NL 조인]]이 유리하다.
- 그렇기 때문에 인덱스를 효과적으로 활용하는 것이 중요하다.

배치 프로그램 튜닝은 보통 대량의 데이터를 읽고 갱신한다.
- [[해시 조인]]이 유리하다.
- Table Full Scan을 사용하는 것이 좋지만, 초대용량 테이블의 경우 이마저도 부담스럽다.
- 그렇기 떄문에 [[파티션]] 활용 전략, [[병렬 처리]] 등이 매우 중요하다.


## 3.1.4 인덱스 컬럼 추가

테이블 액세스를 했지만 필터 조건에 의해 버려지는 레코드들이 많을 경우,
인덱스 튜닝을 통해 불필요한 테이블 액세스를 최소화 할 수 있다.

테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 [[인덱스 튜닝 기법]]은 인덱스에 컬럼을 추가하는 것이다.

추가적으로, 클러스터링 팩터를 고려한 컬럼을 추가하여 블록 I/O를 줄일 수도 있다.


## 3.1.5 인덱스만 읽고 처리

테이블 랜덤 액세스가 아무리 많아도 필터 조건에 의해 버려지는 레코드가 거의 없는 경우도 있다.
이럴 경우 테이블 액세스를 최소화하기 힘들다. (불필요한 테이블 액세스가 아니기 때문)

이를 개선하기 위해 테이블 액세스를 하지 않고 인덱스 테이블 만으로 처리할 수 있도록 컬럼을 추가해줄 수 있다.
그러나 현실적으로 적용하기 힘든 경우가 많다.

#### Include 인덱스

 - [ ] 어떤 DBMS에서 사용 가능한지 확인 필요

인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능

오로지 테이블 랜덤 액세스를 줄이는 용도로 개발되었다.

왜 쓰니..?


## 3.1.6 [[인덱스 구조 테이블]]

아예 랜덤 액세스가 발생하지 않도록 테이블을 인덱스 구조로 생성할 수도 있다.

인위적으로 클러스터링 팩터를 좋게 만드는 것으로, 시퀀셜 액세스가 가능하다.


## 3.1.7 [[클러스터 테이블]]

인덱스 클러스터 테이블과 해시 클러스 테이블을 사용하여 랜덤 액세스를 최소화할 수 있다.

---

# 3.3 인덱스 스캔 효율화

## 3.3.1 인덱스 탐색

[[인덱스 탐색]]은 수직적 탐색 후, 수평적으로 탐색하여 조건에 맞는 값들을 찾는다.

조건절이 수직적 탐색 과정에 사용됐다면 스캔의 시작점을 결정하는 데에 중요한 역할을 한 것이다.
조건절이 수평적 탐색 과정에 사용됐다면 스캔을 멈추는 데에 중요한 역할을 한 것이다.

위의 두 경우 모두 결과적으로는 스캔량을 줄이는 역할을 한 것이다.

그러나 어떤 조건절을 사용하냐에 따라 스캔량을 전혀 줄이지 못할 수도 있다.

![[Pasted image 20231210193737.png|500]]

위와 같은 경우 C2에 대한 조건절은 B 구간에서 스캔량을 줄이는 데에 거의 역할을 못 했다.


## 3.3.2 인덱스 스캔 효율성

>Q) '성능'으로 시작하고 네 번째 문자가 '선'인 용어를 검색할 때, 어디서 스캔을 시작하고 어디서 멈출까?
>A) '성능'으로 시작하는 용어들을 Full Scan해야 한다.

이처럼 인덱스의 선행 컬럼이 조건절에 없을 경우, 인덱스 스캔 과정에서 비효율이 발생한다.
(세 번째 문자가 '개'라는 조건절을 추가하면 '성능개선'이라는 레코드를 시작으로 네 번째 문자가 '선'이 아닐 때까지만 스캔하면 된다.)

### 인덱스 스캔 효율성 측정

**SQL 트레이스를 통해 쉽게 알 수 있다.**

![[Pasted image 20231210195944.png|500]]

인덱스를 스캔하고 얻은 레코드는 10개이지만, 그 과정에서 7463개의 블록을 읽었다.
한 블록당 평균 500개의 레코드가 담긴다고 가정하면 300만 개 이상의 데이터를 읽은 것이다.


## 3.3.3 엑세스 조건과 필터 조건

![[Pasted image 20231210201754.png|400]]

[[인덱스 액세스 조건]]은 인덱스의 스캔 범위를 결정한다.

[[필터 조건]]은 테이블 액세스 단계에서 처리되는 조건절이다.

인덱스를 이용한 테이블 액세스 비용 공식은 아래와 같다.
>비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
>즉, 각 과정에서 읽는 블록 수를 모두 더한 값이다.


## 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성

인덱스는 **같은 값**을 갖는 레코드들이 서로 군집해있다.

선행 컬럼에 대한 조건을 누락하거나 '=' 조건이 아닌 연산자로 조회하면 조건절을 만족하는 레코드가 서로 흩어진 상태가 된다.
- 선행 컬럼이 모두 '=' 조건인 상태에서, 첫 번째로 나타나는 범위검색 조건까지는 인덱스 레코드가 모여있다.
- 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류와 상관없이 흩어진다. (예외는 있을 수 있다)

즉, 첫 번째로 나타나는 범위검색 조건까지가 **인덱스 액세스 조건**이다.
나머지 인덱스 컬럼 조건들은 모두 인덱스 필터 조건이다.

그러나 **아래의 케이스**(인덱스를 사용할 수 없는 경우)를 제외하면
인덱스 컬럼에 대한 조건절은 SQL 실행계획 상에서 대부분 액세스 조건에 표시된다.
- 스캔 범위를 줄이는 데 큰 역할을 못해도 줄이긴 줄이니까...

1. 좌변 컬럼을 가공한 조건절
2. 왼쪽 '%' 혹은 양쪽 '%' 기호를 사용한 like 조건절
3. 같은 컬럼에 대한 조건절이 두 개 이상일 때, 인덱스 액세스 조건으로 선택되지 못한 조건절
4. [[OR Expansion]] 또는 [[IN-List Iterator]]로 선택되지 못한 OR 또는 IN 조건절


## 3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때, 인덱스 효율성이 가장 좋다.

인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다.
- 선행 컬럼일 경우에는 대부분 비효율이 생긴다!


## 3.3.6 BETWEEN을 IN-List로 전환

[[IN-List Iterator]] 변환을 통해, IN-List의 개수만큼 Index Range Scan을 반복한다.
- 범위 연산자가 아닌 등치 연산자를 사용하기 때문에 더욱 효율적이다.

![[Pasted image 20231210211121.png|600]]

IN-List 항목 개수가 늘어날 수 있다면, BETWEEN을 IN-List로 변환하기가 어렵다.
- 그럴 때는 NL 방식의 조인문이나 서브쿼리로 구현하면 된다.
- [ ] 4장에서 NL 조인을 학습하고 다시 이해

### BETWEEN 조건을 IN-List로 전환할 때의 주의사항

**IN-List의 개수가 많지 않아야 한다!**

![[Pasted image 20231210211606.png|500]]

오른쪽 그림처럼 수직적 탐색이 더 많이 발생하게 된다.
- 리프 블록을 스캔하는 비효율보다 브랜치 블록을 반복 탐색하는 비효율이 더 클 수도 있다.

**반드시 수직적 탐색 비용을 따져보고 IN-List로의 전환을 사용하자!**


## 3.3.7 Index Skip Scan 활용

조건절을 바꾸지 않고도 같은 효과를 낼 수 있다.

![[Pasted image 20231210212141.png|500]]

인덱스가 (판매월, 판매구분)와 같이 이루어졌을 경우, 판매구분=A인 레코드만을 탐색하려고 해도 B까지 모두 읽는 비효율이 발생한다.

이 때, [[Index Skip Scan]]을 유도한다면 큰 비효율 없이 레코드를 탐색할 수 있다.

**선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져있을 때, Index Skip Scan을 사용하도록 하자!**


## 3.3.8 IN 조건은 '='인가

위의 "BETWEEN 조건을 In-List로 전환할 때의 주의사항"과 비슷한 맥락이다.
수직적 탐색 비용을 고려하여 IN-List Iterator를 사용하자.

### NUM_INDEX_KEYS 힌트 활용

IN-List를 액세스 조건 또는 필터 조건으로 유도할 수 있다.

인덱스는 (고객번호, 상품ID)와 같이 구성되어 있다.

**고객번호만 인덱스 액세스 조건으로 사용**
- IN-List Iterator 방식을 사용하지 않는다. (필터 조건으로 사용)
![[Pasted image 20231210213710.png|500]]

**(고객번호, 상품ID)를 인덱스 액세스 조건으로 사용**
- IN-List Iterator 방식을 사용하게 된다. (액세스 조건으로 사용)
![[Pasted image 20231210213717.png|500]]


## 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

**LIKE보다 BETWEEN을 사용하는 게 낫다!**

![[Pasted image 20231210214533.png|500]]

![[Pasted image 20231210214459.png|500]]

- [ ] LIKE를 사용할 때는 IN-List Iterator나 Index Skip Scan을 사용할 수 없나?


## 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

코딩을 쉽게 하기 위해 인덱스 컬럼에 범위검색 조건을 남용하면 인덱스 스캔 비효율이 생긴다.
번거롭더라도 비효율이 예상된다면 SQL을 더 작성하자.


## 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

**옵션 조건은 있을 수도 있고, 없을 수도 있는 조건절이다.**

### OR 조건 활용

그러나 이는 OR Expansion이 기본적으로 동작하지 않기 때문에
인덱스에서 스캔한 만큼 테이블을 랜덤 액세스한 후에 필터링을 거친다.

- 인덱스 액세스 조건으로 사용 불가
- 인덱스 필터 조건으로 사용 불가
- 테이블 필터 조건으로만 사용 가능
- 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면, 인덱스 필터 조건으로 사용 가능

### LIKE / BETWEEN 조건 활용

필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면,
LIKE / BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있다.

그러나 필수 조건의 변별력이 좋지 않을 때는 [[Table Full Scan]]이 유리할 수도 있다.

아래의 4가지 경우일 때는 LIKE / BETWEEN 조건을 사용하지 않는 것이 좋다.
- 인덱스 선두 컬럼
- NULL 허용 컬럼
- 숫자형 컬럼
- 가변 길이 컬럼

### UNION ALL 활용

