---
{}
---

# 하드웨어와 제어구조


## 캐시 메모리 시스템 vs 가상 메모리 시스템

### 캐시 메모리 시스템

주기억장치에 대한 **CPU의 접근 속도를 빠르게** 하는 것이 목적

### 가상 메모리 시스템

적은 주기억장치 용량으로도 **많은 주기억장치가 있는 것처럼 사용**하는 것이 목적


## 가상 메모리의 특성

### [[논리주소]]와 물리주소

프로세스의 메모리 주소는 논리주소로 변환하여 적재된다.
- 이는 MMU에 의해 CPU 수행 시에 물리주소로 변환된다.

### 불연속 메모리 관리

프로세스의 주소공간이 **여러 블록(페이지나 세그먼트)으로 분할**되어 **순서와 무관하게 주기억장치 상에 배치**되어 수행될 수 있다.

프로세스를 구성하는 블록 중 일부만 주기억장치 상에 적재한 채 수행할 수 있다.
- 이는 가상 메모리 관리에서만 가능하다.

#### 적재집합
- 특정 프로세스의 주소공간 중 주기억장치에 적재된 블록들의 집합

#### 메모리접근 오류
- 주기억장치에 적재되지 않은 블록이 참조될 경우 발생하는 하드웨어 이벤트(인터럽트)
- 메모리접근 오류가 발생했을 경우, 해당 프로세스는 **1)블록 상태**가 되며 **2)참조할 블록이 디스크로부터 적재될 때까지 대기**한 후 적재가 되었다면 다시 **3)준비 상태**가 된다.


## 가상메모리와 물리메모리

한 프로세스의 **전체 주소공간(가상 주소 공간)은 디스크(가상메모리)에 설정**되고, 그 중 **일부분만이 주기억장치(물리메모리)에 적재**되어 CPU에 의해 참조된다.

### 부분적재 수행의 이점

프로그램을 일부만 로드 -> 쪼개기 가능하기 때문 -> 일부만 메모리에 적재 -> 이를 관리할 필요 -> 정보 기록 필요 -> 가상 메모리를 통해 다른 주소를 쓰면서 물리 메모리를 매핑

1. 보다 많은 개수의 프로세스를 주기억장치에 유지할 수 있다.
	1. 준비 상태인 프로세스가 존재할 가능성이 높아지기 때문에 CPU 활용도가 높아진다.
2. 주기억장치보다 큰 프로세스를 수행할 수 있다.
	1. 기존 [[메모리 오버레이 기법]]의 경우, 프로그래머가 가용 메모리 크기 파악, 주소공간의 블록 분할, 언제 어떤 블록이 필요한지 파악, 주기억장치와 디스크 간의 블록 교체 작업 등을 직접 고려해야 하는 부담이 있었지만, **가상메모리의 경우에는 이를 운영체제가 담당**한다.


## 가상메모리와 물리메모리의 매핑

> 페이지(가상) 크기 = (페이지) 프레임(물리) 크기

**페이지 번호**는 가상 주소 공간을 페이지 크기로 나눈 몫으로 페이지 번호를 부여한다. (0번부터 시작)
**프레임 번호**는 주기억장치 공간을 프레임 크기로 나눈 몫으로 프레임 번호를 부여한다. (0번부터 시작)

가상주소를 물리주소로 변환하는 과정은 **MMU**(메모리 관리장치)에 의해 수행된다.
- 주소간의 변환관계를 정의한 정보는 **페이지 테이블**에 보관한다. (OS가 관리)
- 페이지 테이블에 매핑 정보가 없을 경우에는 메모리 접근 오류가 발생한 것이므로, 프로세스는 참조할 블록이 디스크로부터 적재될 때까지 대기 상태가 된다.


## 가상메모리의 동작 원리

가상메모리의 동작에는 CPU, MMU, OS가 관여한다.

1. CPU는 가상메모리 주소공간 중 특정 주소를 접근 (가상주소/논리주소)
2. MMU는 이 주소가 현재 물리메모리에 있는지 페이지 테이블을 참조해 판단
	1. **현재 물리메모리에 있는 주소라면** 
		1. 가상주소를 물리주소로 변환하여 CPU의 해당 물리메모리 접근을 허용
	2. **현재 물리메모리에 없는 주소라면**
		1. OS는 물리메모리에 빈 공간을 만들고 **디스크에서 해당 주소의 내용을 물리 메모리로 복사** 및 **페이지 테이블 갱신**
		2. 가상주소를 물리주소로 변환하여 CPU의 해당 물리메모리 접근을 허용


## 가상메모리의 실용성

### 요구 페이징 (demand paging)

프로그램 수행에 필요한 페이지만 적재하므로, 비사용 블록 적재로 인한 낭비 최소화

### 페이지 적재 요구가 얼마나 빈번한지?

임의의 구간을 관찰했을 때, 메모리 참조 행태가 너무 분산되지 않아야 한다.
- 한 번 주기억장치에 적재된 블록들이 swap-out되기 전까지 **최대한 많이 참조되도록 관리**해야 한다. (지역성의 원리)

시스템이 안정상태에 있을 경우, 주기억장치 전체가 각 프로세스의 블록들로 채워진다.
- 이 때, **주기억장치에 적재되지 않은 블록이 참조되면 이미 적재된 블록을 교체**해야 한다.

결론적으로 가상메모리의 실용성을 위해서는 **쓰레싱 방지**가 관건이다.
- 쓰레싱(thrashing): 시스템이 프로세스 수행보다 블록 교체에 대부분의 시간을 소비하게 되는 현상

### 프로세스의 성긴(sparse) 주소공간 활용

스택은 위에서 아래로, 힙은 아래에서 위로 할당된다.
- 이 때 중간의 공백도 가상 주소 공간의 일부이다.

가상 메모리에서 공백은 실제 메모리가 할당되지 않는다.
- 스택이나 힙이 확장되어야만 실제 물리 페이지를 요구하게 된다.
- **현재 직접적으로 필요하지 않은 메모리 공간은 물리 메모리에 올리지 않는다.**

### 공유 라이브러리

시스템 라이브러리를 여러 프로세스가 공유하는 것이다.
- 각 프로세스들은 공유 라이브러리를 자신의 가상 주소공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가있는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다.

데이터용 공유 메모리(shared memory)

`fork()` 시 자식 프로세스의 빠른 생성이 가능하다.
- 복사하는 것이 아닌, 페이지들을 공유하기 때문이다.

### 쓰기 시 복사

초기에는 부모, 자식 프로세스가 페이지들을 공유한다.

공유된 페이지의 내용을 변경할 때만 **해당 페이지를 복사하여 새로운 페이지를 만들고**, **해당 프로세스의 페이지 테이블을 갱신**한다.

### 메모리 사상 파일

디스크의 파일을 메모리에 매핑시키고, 메모리에 접근하듯이 파일을 사용한다.
- 파일 접근과 사용을 단순화 한다. (`read()`, `write()` 없이 파일 데이터 사용, `mmap()` 시스템 호출)

![[Pasted image 20240124224733.png|500]]


## 페이징

[[가상 메모리 페이징]]


## 지역성의 원리

[[지역성의 원리]]

지역성의 원리와 가상 메모리는 어떤 연관성이 있는데?


## 가상메모리 관리 정책

[[가상 메모리 관리 정책]]

## Ref

[가상 메모리 관리](https://velog.io/@jsb100800/CS-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC)
[가상 메모리 (Virtual Memory)](https://velog.io/@xx0hn/CS-OS-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-Virtual-Memory)
역페이지 테이블
https://itstory1592.tistory.com/103
https://neos518.tistory.com/125
https://m.blog.naver.com/kgr2626/222147145792