## 기본 알고리즘

### 최적 (Optimal)

가장 오랫동안 **참조되지 않을** 페이지를 교체한다.
- 미래를 봐야 한다...! -> 이상적이나 구현은 불가능
- 다른 알고리즘을 평가하기 위한 참고용으로만 사용한다.

### LRU (Least Recently Used)

가장 오랫동안 **참조되지 않은** 페이지를 교체한다.
- 최적에 근접한 성능이지만, 구현이 어렵고 오버헤드가 크다.

#### LRU의 구현
1. 각 페이지의 최종 참고 시간을 해당 페이지에 **태그**로 설정
	1. 교체 시 각 페이지의 태그에 있는 참고시간을 모두 비교하여 교체 대상을 선택한다.
2. 페이지 참조들에 대해 **스택**을 이용
	1. 스택의 하단이 우선 교체 대상이 된다.

### FIFO (First-In First-Out)

가장 오래 전에 적재된 페이지를 교체한다.
- 구현이 매우 쉽다.
- 집중적으로 반복되는 패턴에 대해서도, 버퍼 범위 밖이라면 페이지 폴트가 발생하게 된다.

### 클럭 (Clock) - 2차 기회 알고리즘이라고도 하는듯?

물리메모리 내에 적재된 페이지의 시간과 사용빈도를 고려하여 교체한다. (FIFO + LRU)
- FINUFO (First-In-Not-Used-First-Out)

#### 클럭정책의 기본 형태 (FIFO + 사용비트)
- 페이지를 적재한 프레임들이 **환형**으로 배치되어 있다고 간주하고, 첫 교체후보를 가리키는 포인터를 설정한다.
- 프레임 별로 **사용비트**라는 1비트를 연계시켜, 처음 반입 시와 참조 시 1로 설정한다.
- 시계 방향으로 포인터를 이동시키면서 포인터가 가리키는 프레임 중
	- 사용비트가 **0**인 첫 프레임 상의 페이지를 **교체**한다.
	- 사용비트가 **1**인 경우 교체하지 않고 사용비트를 **0으로 변경**하고 다음 프레임으로 이동한다. (기회를 줌)
		- 막 반입됐거나 참조된 기록이 있기 때문

#### 변경 비트가 추가된 클럭 정책
- 교체 대상을 검토할 때, **변경된 프레임**일 경우 교체 우선순위를 낮추는 기법이다.
	- 변경된 프레임의 경우, 교체될 때 변경된 내용을 반영하는 과정이 추가적으로 필요하다. (오버헤드 발생)
	- [운영체제 - 가상 메모리](https://velog.io/@kang1221/CS-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC)
- 교체 우선순위
	1. 최근에 참조되지 않았으며, 변경되지 않음
	2. 최근에 참조되지 않았으며, 변경됨
	3. 최근에 참조되었으며, 변경되지 않음
	4. 최근에 참조되었으며, 변경

### LFU (Least Frequently Used)

각 페이지마다 참조 횟수 카운터가 있고, **카운터 수가 가장 적은 페이지**를 우선적으로 교체한다.
그러나 프로세스의 초기 단계에서 한 페이지를 많이 사용한 후 다시는 사용하지 않을 경우 비효율적이다.
- 시간 대비 평균 사용 수 도입

### MFU (Most Frequently Used)

마찬가지로 카운터가 있고, **카운터 수가 가장 많은 페이지**를 교체한다.
카운터 수가 적은 페이지는 막 들어온 것이기 때문에 앞으로 사용할 확률이 높을 것이라고 예상한다.
- 그러나 이러한 상황은 일반적이지 않다.


## 페이지 버퍼링

교체 대상을 즉시 교체하지 않고, **일정 기간 동안 주기억장치 상에 유지**한다.
- 가용프레임(주메모리의 일부) 여러 개를 풀로 가지고 있다.
- [Virtual Memory(1)](https://twinw.tistory.com/106)

페이지의 성능을 향상시키는 동시에 단순한 페이지 교체 정책을 허용한다.
- FIFO 방식으로 교체 대상을 선택 (**단순한 페이지 교체 정책**)
- 선택된 페이지를 일정 기간 동안 주기억장치에 유지 (재활용 가능, **페이지 성능 향상**)

##### 교체될 페이지가 **수정이 없다면** 가용페이지 리스트의 뒤쪽에 등록한다.
- 새로운 페이지가 들어올 때, 가용페이지 리스트에 등록된 첫번째 페이지가 사용된다.

##### 교체될 페이지가 **수정이 있다면** 변경페이지 리스트의 뒷쪽에 등록한다.
- 스케줄러에 의해 저장될 때까지 잔류, 스케줄링되면 변경된 내용을 디스크에 저장한다.
- 한번에 묶어서(클러스터) 저장이 가능하므로 **디스크 입출력을 최소화**할 수 있다.

목적은 디스크 액세스와 관련된 지연을 줄이는 것이다.

