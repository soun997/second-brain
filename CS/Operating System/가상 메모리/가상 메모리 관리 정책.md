## 반입정책 (Fetch Policy)

> 각 페이지를 주기억장치로 언제 적재할 것인가?

두 가지의 반입 정책이 있다.

### 요구반입(Demand Paging)

가장 일반적인 방법으로, **페이지폴트가 발생할 경우** 해당 페이지만을 주기억장치에 적재한다.
아무것도 적재되지 않은 **초반에 많은 페이지폴트**가 발생하지만, **지역성의 원리**에 의해 시간이 지날 수록 **안정적인 운용**이 가능해진다.

### 선반입

페이지폴트에 의해 요구된 페이지 뿐만 아니라, **주변 페이지까지도 주기억장치에 적재**한다.
한 프로세스의 페이지들이 보조기억장치에 **연속적으로 저장**되어 있을 경우, 이들을 **한꺼번에 반입**하는 것이 더욱 효율적이기 때문이다.
- 가상 메모리 상의 연속된 페이지는 보조기억장치 내에서도 연속배치되어 있을 가능성이 높다.
- 디스크의 탐색시간, 회전시간의 최소화가 가능하다.
##### SSD가 상용화된 지금에서는 선반입 방식이 굳이 필요한가? 하는 생각이 든다.

#### 선반입 정책을 보편적으로 사용하지 않는 이유는?

한꺼번에 반입하는 페이지들이 반드시 필요할 것이라는 보장이 없다.
그러므로 오히려 주기억장치를 낭비하는 꼴이 될 것이다.

#### [[스와핑]]과의 구분?

뭘 구분하라는 건지..? 너무 다른데?


## 배치정책(Placement Policy)

> 블록을 주기억장치의 어디에 위치시킬 것인가?

[[페이징]] 시스템의 경우, 주기억장치와 프로세스를 같은 크기의 페이지/프레임으로 나눈다.
- 이는 어디에 적재하든 같은 효율로 기능하는 것을 의미한다. (**배치정책은 무의미**)

[[세그먼테이션]] 시스템의 경우에는 배치 전략이 필요해진다.
- 최초 적합, 최적 적합, 최악 적합, 순환 최초 적합 기법 등이 있다.
- [[가변 분할 기법]]의 배치 알고리즘 참조

[[NUMA]](NonUniform Memory Access) 구조의 다중처리기인 경우라면 배치정책이 중요해진다.
- 각 페이지를 그것을 참조할 **처리기와 가까운 메모리 모듈**에 배치시키는 전략이 필요하다.


## 교체정책(Replacement Policy)

> 가용 프레임이 없을 경우, 새로운 페이지를 반입하기 위해 어떤 페이지를 교체할 것인지?

교체정책의 목표는 **가까운 미래에 참조될 가능성이 가장 적은 페이지**를 선택하여 교체하는 것이다.
[[지역성의 원리]]를 전제로 하여, 과거의 참조 행태에 근거하여 미래의 참조 가능성을 예측한다.

### 프레임 잠금

일부 프레임을 **교체 대상에서 배제**시키기 위한 방식이다.
- 운영체제 커널 중 주요 자료구조, 입출력 버퍼, 시간이 중요한 영역
- 프레임테이블, 페이지테이블


