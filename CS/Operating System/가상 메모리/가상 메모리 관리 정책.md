## 반입정책 (Fetch Policy)

> 각 페이지를 주기억장치로 언제 적재할 것인가?

두 가지의 반입 정책이 있다.

### 요구반입(Demand Paging)

가장 일반적인 방법으로, **페이지폴트가 발생할 경우** 해당 페이지만을 주기억장치에 적재한다.
아무것도 적재되지 않은 **초반에 많은 페이지폴트**가 발생하지만, **지역성의 원리**에 의해 시간이 지날 수록 **안정적인 운용**이 가능해진다.

### 선반입

페이지폴트에 의해 요구된 페이지 뿐만 아니라, **주변 페이지까지도 주기억장치에 적재**한다.
한 프로세스의 페이지들이 보조기억장치에 **연속적으로 저장**되어 있을 경우, 이들을 **한꺼번에 반입**하는 것이 더욱 효율적이기 때문이다.
- 가상 메모리 상의 연속된 페이지는 보조기억장치 내에서도 연속배치되어 있을 가능성이 높다.
- 디스크의 탐색시간, 회전시간의 최소화가 가능하다.
##### SSD가 상용화된 지금에서는 선반입 방식이 굳이 필요한가? 하는 생각이 든다.

#### 선반입 정책을 보편적으로 사용하지 않는 이유는?

한꺼번에 반입하는 페이지들이 반드시 필요할 것이라는 보장이 없다.
그러므로 오히려 주기억장치를 낭비하는 꼴이 될 것이다.

#### [[스와핑]]과의 구분?

뭘 구분하라는 건지..? 너무 다른데?


## 배치정책 (Placement Policy)

> 블록을 주기억장치의 어디에 위치시킬 것인가?

[[페이징]] 시스템의 경우, 주기억장치와 프로세스를 같은 크기의 페이지/프레임으로 나눈다.
- 이는 어디에 적재하든 같은 효율로 기능하는 것을 의미한다. (**배치정책은 무의미**)

[[세그먼테이션]] 시스템의 경우에는 배치 전략이 필요해진다.
- 최초 적합, 최적 적합, 최악 적합, 순환 최초 적합 기법 등이 있다.
- [[가변 분할 기법]]의 배치 알고리즘 참조

[[NUMA]](NonUniform Memory Access, 불균일 기억 장치 접근) 구조의 다중처리기인 경우라면 배치정책이 중요해진다.
- 각 페이지를 그것을 참조할 **처리기와 가까운 메모리 모듈**에 배치시키는 전략이 필요하다.


## 교체정책 (Replacement Policy)

> 가용 프레임이 없을 경우, 새로운 페이지를 반입하기 위해 어떤 페이지를 교체할 것인지?

교체정책의 목표는 **가까운 미래에 참조될 가능성이 가장 적은 페이지**를 선택하여 교체하는 것이다.
[[지역성의 원리]]를 전제로 하여, 과거의 참조 행태에 근거하여 미래의 참조 가능성을 예측한다.

### 프레임 잠금

일부 프레임을 **교체 대상에서 배제**시키기 위한 방식이다.
- 운영체제 커널 중 주요 자료구조, 입출력 버퍼, 시간이 중요한 영역
- 프레임테이블, 페이지테이블

### 교체 알고리즘

[[교체 알고리즘]]


## 적재집합 관리 (Resident Set Management)

> 개별 프로세스에게 얼마만큼의 주기억장치를 제공할 것인가?

### 적재집합의 크기 관리

#### 고정할당
- 프로세스 생성 시 특성에 맞게 프로세스에 할당된 **프레임 수를 고정**
- 전역 범위 교체가 불가하다.

#### 가변할당
- 프로세스에 할당된 **프레임 수를 동적으로 변경**
- 전역 범위 교체 시, 프로세스의 적재집합 크기가 변경될 가능성 존재

### 교체범위 관리

#### 지역범위
- 페이지 폴트가 발생한 해당 프로세스의 적재집합 내에서 교체 대상 선택

#### 전역 범위
- 주기억장치 상의 모든 페이지 중에서 교체 대상 선택

### 고정할당 + 지역범위

프로세스 생성 시, 고정된 프레임 할당량을 결정한다.
- 할당량이 너무 적을 경우, 높은 페이지 폴트 발생률
- 할당량이 많아질 경우, 처리기 유휴시간이나 스와핑 시간 증가 -> 동시에 사용 가능한 프로세스 개수 적어짐

### 가변할당 + 전역범위

프로세스에 할당된 프레임을 동적으로 변경하고, 교체될 대상을 전체 주기억장치에서 선택한다.
- 구현이 쉽기 때문에 **많은 운영체제에서 이를 채택**한다.

#### 구현 전략
- 운영체제는 가용프레임 리스트르 유지한다.
- 페이지 폴트가 발생했을 경우, 해당 프로세스의 적재집합에 가용프레임을 추가해주어 프레임을 확보한다.
	- 가용 프레임이 없을 경우, **모든 프레임을 대상**으로 교체 대상 페이지를 선택하여 **소유한 프로세스의 적재집합 크기를 축소**하며 교체 (기브앤테이크)

#### 문제점 및 개선책
- 프레임을 기준으로 선택하기 때문에 프로세스의 중요도가 무시된다.
- 개선책: 페이지 버퍼링 ([[교체 알고리즘]]의 페이지버퍼링 참고)
	- 페이지가 덮여 쓰이기 전에 참조될 경우 효율적으로 회수될 수 있다.

### 가변할당 + 지역범위

#### 구현 전략
- 프로세스를 처음 적재할 때, 어느 정도의 프레임을 적재집합으로 할당한다.
- 수시로 프로세스에 대한 **할당량을 재평가**하고 전체적인 성능 개선 측면에서 할당량을 증감한다.
- 페이지폴트 발생 시, 해당 프로세스의 적재집합 내에서 교체한다.

#### 대표적 전략
- [[작업집합 전략]]
- [[PFF]] (Page Fault Frequency)
- [[VSWS]]


## 클리닝 정책 (Cleaning Policy)

> 변경된 페이지들을 언제 보조기억장치에 기록할 것인지?

### 요구 클리닝

페이지가 교체될 때 기록한다.
- 교체될 페이지가 보조기억장치에 써지는 동안 **새로운 반입작업은 대기**해야 한다.

### 선클리닝

운영체제가 일정한 간격마다 변경된 페이지들을 기록한다.
- 일괄 기록이 가능하다는 장점이 있으나, 교체 전에 다시 바뀐다면 불필요한 작업이 된다. (??)

### 페이지 버퍼링과의 접목

1. 변경된 페이지가 교체 후보라면 변경 리스트에 연결한다.
2. 변경 리스트의 내용들을 주기적으로 일괄기록한다.
3. 기록된 것들은 가용리스트로 이동한다.
4. 새로운 페이지 반입 시에 가용리스트 상의 프레임을 할당하여 신규 페이지를 적재한다.
	1. 페이지 교체 시에 이미 기록된 상태이기 때문에 추가적인 기록이 필요없어진다.


## 부하제어 (Load Control)

> 주기억장치에 몇 개의 프로세스를 적재할 것인지?

메모리에 적재된 프로세스의 수가 **너무 적으면**, 모든 프로세스가 블록 상태인 경우가 잦기 때문에 **스와핑에 많은 시간이 소요**된다.

반대로 메모리에 적재된 프로세스의 수가 **너무 많으면**, 각 프로세스의 적재집합을 구성하는 **평균 페이지 수가 부족**해서 잦은 페이지폴트가 발생하고, 궁극적으로 [[쓰레싱]]이 발생하게 된다.